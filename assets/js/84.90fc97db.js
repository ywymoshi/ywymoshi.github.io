(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{435:function(v,_,r){"use strict";r.r(_);var t=r(25),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h2",{attrs:{id:"活动图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#活动图"}},[v._v("#")]),v._v(" 活动图")]),v._v(" "),r("ul",[r("li",[v._v("描述工作流和并行过程的行为。")]),v._v(" "),r("li",[v._v("活动图本质上是一种流程图，它描述活动的序列，即系统从一个活动到另一个活动的控制流。")])]),v._v(" "),r("p",[r("strong",[v._v("包含的元素：")])]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("活动：")]),v._v("  表示的是某流程中的任务的执行，它可以表示某算法过程中语句的执行。活动在活动图中表现为一个由一系列动作组成的非原子的执行过程。")]),v._v(" "),r("ul",[r("li",[r("strong",[v._v("动作状态：")]),v._v(" 执行原子的、不可中断的动作，并在此动作完成后通过完成转换转向另一个状态的状态")]),v._v(" "),r("li",[r("strong",[v._v("活动状态：")]),v._v(" 活动状态是可分解的，不是原子的，其工作的完成需要一定的时间")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("动作流：")]),v._v(" 所有动作状态之间的转换流称之为动作流，活动图的转换用带箭头的直线表示。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/3-1.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("分支与合并：")]),v._v(" 分支表示对象类所具有的条件行为，条件行为用分支和合并表达。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/3-2.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("分叉和汇合：")]),v._v(" 分叉用于将动作流分为两个或者多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/3-3.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("泳道：")]),v._v(" 泳道将活动图中的活动化分为若干组，并把每一组指定给负责这组活动的业务组织，通常为对象。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/3-4.png",alt:"img"}})])])]),v._v(" "),r("h2",{attrs:{id:"时序图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#时序图"}},[v._v("#")]),v._v(" 时序图")]),v._v(" "),r("p",[v._v("是显示对象之间交互的图，这些对象是按时间顺序排列的。顺序图中显示的是参与交互的对象及其对象之间消息交互的顺序。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/4-1.png",alt:"img"}})]),v._v(" "),r("p",[r("strong",[v._v("包含的元素：")])]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("角色(Actor)：")]),v._v(" 用以表示和系统进行交互的参与者角色，不一定是人也可以是物或者系统。UML用例图中用一个小人来表示角色"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/4-2.png",alt:"img"}})]),v._v(" "),r("ul",[r("li",[r("strong",[v._v("对象（Object）：")]),v._v(" 对象就是类的实例。UML用例图中用矩形框来表示对象。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/4-2-1.png",alt:"img"}})]),v._v(" "),r("li",[r("strong",[v._v("生命线（Lifeline）：")]),v._v(" 角色、对象的虚线部分")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("控制焦点：")]),v._v(" 控制焦点代表对象在某一用例过程中执行某一操作的时间。UML用例图中用方块来表示控制焦点"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/4-3.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("消息：")]),v._v(" 消息是角色和对象或者对象与对象之间的信息传递。消息分为四种：同步消息、异步消息、返回消息、自关联消息。")]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("同步消息：")]),v._v(" 把信息传递给接受者后，停止活动，等待返回结果。使用(实线)"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/4-4.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("异步消息：")]),v._v(" 把信息传递给接受者后，不用等待返回结果。可以直接开始下一个活动。\n"),r("img",{attrs:{src:"/img/softwareRequire/4-5.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("返回消息：")]),v._v(" 代表从过程调用返回"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/4-6.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("自关联消息：")]),v._v(" 自关联消息表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/4-7.png",alt:"img"}})])])])])]),v._v(" "),r("h2",{attrs:{id:"状态图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#状态图"}},[v._v("#")]),v._v(" 状态图")]),v._v(" "),r("p",[v._v("是显示对象之间交互的图，这些对象是按时间顺序排列的。顺序图中显示的是参与交互的对象及其对象之间消息交互的顺序。")]),v._v(" "),r("p",[r("strong",[v._v("包含的元素：")])]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("状态：")]),v._v(" 指在对象的生命周期中的某个条件或者状况，在此期间对象将满足某些条件、执行某些活动活活等待某些事件。所有对象都有状态，状态是对象执行了一系列活动的结果，当某个事件发生后，对象的状态将发生变化"),r("br"),v._v(" "),r("strong",[v._v("状态组成：")]),v._v("\n状态=状态名+动作（可选）"),r("br"),v._v("\nentry：入口动作。当进入一个状态的时候执行。"),r("br"),v._v("\ndo：内部活动。当状态处于激活时执行"),r("br"),v._v("\nexit：出口动作。当离开一个状态的时候执行。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/5-1.png",alt:"img"}})]),v._v(" "),r("ul",[r("li",[r("strong",[v._v("简单状态：")]),v._v(" 没有子结构的状态")]),v._v(" "),r("li",[r("strong",[v._v("初始状态：")]),v._v(" 表示状态机状态的起点。")]),v._v(" "),r("li",[r("strong",[v._v("终止状态：")]),v._v(" 表示状态机状态的起点。")]),v._v(" "),r("li",[r("strong",[v._v("复合状态：")]),v._v(" 被分成两个或者多个并发子状态，当复合状态被激活时，所有的子状态均被激活"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/5-2.png",alt:"img"}})])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("迁移：")]),v._v("  转移（Transitions）是两个状态之间的一种关系，表示对象将在源状态（Source State）中执行一定的动作，并在某个特定事件发生而且某个特定的警界条件满足时进入目标状态（Target State）")]),v._v(" "),r("ul",[r("li",[r("strong",[v._v("事件标记（Trigger）：")]),v._v(" 是转移的诱因，可以是一个信号，事件、条件变化（a change in some condition）和时间表达式。")]),v._v(" "),r("li",[r("strong",[v._v("警界条件（Guard Condition）：")]),v._v(" 当警界条件满足时，事件才会引发转移（Transition）。")]),v._v(" "),r("li",[r("strong",[v._v("结果（Effect）：")]),v._v(" 对象状态转移后的结果。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/5-3.png",alt:"img"}})])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("线程状态图：")])])])]),v._v(" "),r("ol",[r("li",[r("strong",[v._v("新建：")]),v._v(" 初始化对象。Thread t=new Thread")]),v._v(" "),r("li",[r("strong",[v._v("就绪：")]),v._v(" 调用start()方法")]),v._v(" "),r("li",[r("strong",[v._v("运行：")]),v._v(" 执行run()方法")]),v._v(" "),r("li",[r("strong",[v._v("锁阻塞：")]),v._v(" 遇到同步锁。")]),v._v(" "),r("li",[r("strong",[v._v("等待阻塞：")]),v._v(" 调用wait()方法。当调用notify/nofityAll，线程进入锁池，等待获取同步锁。")]),v._v(" "),r("li",[r("strong",[v._v("睡眠/联合阻塞：")]),v._v(" 调用sleep/join方法。")]),v._v(" "),r("li",[r("strong",[v._v("销毁：")]),v._v(" run()方法执行完成。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/5-4.png",alt:"img"}})])]),v._v(" "),r("h2",{attrs:{id:"类图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类图"}},[v._v("#")]),v._v(" 类图")]),v._v(" "),r("p",[v._v("显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图是面向对象建模的主要组成部分\n"),r("strong",[v._v("示例：")]),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/6-1.png",alt:"img"}}),v._v(" "),r("strong",[v._v("包含的元素：")])]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("类名")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("属性")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("方法")]),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/6-2.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("关系")])]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("泛化（Generalization）")])]),v._v(" "),r("ul",[r("li",[v._v("是一种继承关系, 表示一般与特殊的关系, 它指定了子类如何特化父类的所有非private修饰的特征和行为,比如说人有男人和女人,男人和女人即有共性的地方也有差异的地方")]),v._v(" "),r("li",[r("strong",[v._v("箭头指向：")]),v._v(" 带三角箭头的实线，箭头指向父类。"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/6-3.png",alt:"img"}})])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("实现（Realization）")])]),v._v(" "),r("ul",[r("li",[r("p",[v._v("实现和我们java中的实现是一个意思,是一种类与接口的关系, 表示类是接口所有特征和行为的实现")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("箭头指向：")]),v._v(" 带三角箭头的虚线，箭头指向接口"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/6-4.png",alt:"img"}})])])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("关联（Association)")]),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/6-5.png",alt:"img"}})]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("双向关联：")]),v._v(" 默认情况下，关联是双向的。例如：顾客(Customer)购买商品(Product)并拥有商品，反之，卖出的商品总有某个顾客与之相关联。因此，Customer类和Product类之间具有双向关联关系"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/6-6.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("单向关联：")]),v._v(" 类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如：顾客(Customer)拥有地址(Address)，则Customer类与Address类具有单向关联关系"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/6-7.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("自关联：")]),v._v(" 在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如：一个节点类(Node)的成员又是节点Node类型的对象"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/6-8.png",alt:"img"}})])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("多重性关联：")]),v._v(" 多重性关联关系又称为重数性(Multiplicity)关联关系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。对象之间可以存在多种多重性关联关系"),r("br"),v._v(" "),r("img",{attrs:{src:"/img/softwareRequire/6-9.png",alt:"img"}})])])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("聚合（Aggregation）：")])]),v._v(" "),r("ul",[r("li",[r("p",[v._v("是整体与部分的关系, 且部分可以离开整体而单独存在,如车和轮胎是整体和部分的关系,轮胎离开车仍然可以存在。")])]),v._v(" "),r("li",[r("p",[v._v("聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系")])]),v._v(" "),r("li",[r("p",[v._v("在代码实现聚合关系时，成员对象通常作为构造方法、Setter方法或业务方法的参数注入到整体对象中")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("箭头指向：")]),v._v(" 带空心菱形的实心线，菱形指向整体,箭头指向部分。\n"),r("img",{attrs:{src:"/img/softwareRequire/6-10.png",alt:"img"}})])])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("组合(Composition)：")])]),v._v(" "),r("ul",[r("li",[r("p",[v._v("是整体与部分的关系, 但部分不能离开整体而单独存在. 如公司和部门是整体和部分的关系, 没有公司就不存在部门")])]),v._v(" "),r("li",[r("p",[v._v("组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期")])]),v._v(" "),r("li",[r("p",[v._v("在代码实现组合关系时，通常在整体类的构造方法中直接实例化成员类")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("箭头指向：")]),v._v(" 带实心菱形的实线,菱形指向整体\n"),r("img",{attrs:{src:"/img/softwareRequire/6-11.png",alt:"img"}})])])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("依赖(Dependency)：")])]),v._v(" "),r("ul",[r("li",[r("p",[v._v("是一种使用的关系,  即一个类的实现需要另一个类的协助,所以要尽量不使用双向的互相依赖")])]),v._v(" "),r("li",[r("p",[v._v("代码表现：局部变量、方法的参数或者对静态方法的调用")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("箭头指向：")]),v._v(" 带箭头的虚线，指向被使用者\n"),r("img",{attrs:{src:"/img/softwareRequire/6-12.png",alt:"img"}})])])])])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("各种关系的强弱顺序：")]),v._v(" 泛化 >实现>组合> 聚合> 关联> 依赖")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("总结：")]),r("br"),v._v(" "),r("strong",[v._v("(1)依赖关系：")]),v._v(" 关系对象出现在局部变量或者方法的参数里，或者关系类的静态方法被调用")]),v._v(" "),r("p",[r("strong",[v._v("(2)关联关系：")]),v._v(" 关系对象出现在实例变量中")]),v._v(" "),r("p",[r("strong",[v._v("(3)聚合关系：")]),v._v(" 关系对象出现在实例变量中，成员对象通常作为构造方法、Setter方法或业务方法的参数注入到整体对象中")]),v._v(" "),r("p",[r("strong",[v._v("(4)组合关系：")]),v._v(" 关系对象出现在实例变量中，通常在整体类的构造方法中直接实例化成员类。")]),v._v(" "),r("p",[r("strong",[v._v("(5)泛化关系：")]),v._v(" extends")]),v._v(" "),r("p",[r("strong",[v._v("(6)实现：")]),v._v(" implements")])])]),v._v(" "),r("h2",{attrs:{id:"用例图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#用例图"}},[v._v("#")]),v._v(" 用例图")]),v._v(" "),r("p",[v._v("用例图(Use Case Diagram)：主要用于描述系统的行为及各种功能之间的关系，是描述参与者(Actor)与用例以及用例与用例之间关系的图"),r("br"),v._v("\n用例图 = 参与者 + 用例 + 关系")]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("用途：")])]),v._v(" "),r("ul",[r("li",[r("p",[v._v("用例图显示谁将是相关的用户、用户希望系统提供什么服务以及用户需要为系统提供的服务。")])]),v._v(" "),r("li",[r("p",[v._v("通俗的说：描述参与者与用例之间的关系，帮助开发人员可视化的了解系统功能\n"),r("strong",[v._v("包含的元素：")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("参与者（Actor）：")])]),v._v(" "),r("ul",[r("li",[v._v("参与者可以是人或其他外界系统。")]),v._v(" "),r("li",[v._v("参与者是用例的启动者，参与者处于用例的外部并且能够初始化一个用例并参与用例的执行过程，但它并不是系统的一部分。")]),v._v(" "),r("li",[v._v("每个参与者可以参与一个或多个用例。")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("用例（Use Case）：")])]),v._v(" "),r("ul",[r("li",[v._v("用例是一组动作序列（业务工作流程）的描述，系统执行该动作序列为系统的参与者产生一个可观察的结果。")]),v._v(" "),r("li",[v._v("用例反映用户的需求。")]),v._v(" "),r("li",[v._v("用例是一个叙述型的文档，用来描述一个参与者使用系统完成某个事件时的事情发生顺序。（描述参与者与系统的交互）")]),v._v(" "),r("li",[v._v("用例是系统的使用过程，是对系统的用户功能需求的描述，用例表达了系统的功能和所提供的服务。")])])])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("关系：")])]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("关联关系：")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("包含关系：")]),v._v(" 把几个用例的公共步骤分离成一个单独被包含用例；包含用例称为客户用例，被包含用例称为提供者用例。用例A包含用例B，将A称为基用例，B称为被包含用例。\n包含关系表示基用例会用到被包含用例。被包含用例的事件流在基用例的某个点处插入到基用例的事件流中。")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("扩展关系：")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("泛化关系：")]),v._v(" 继承，泛化关系是两个用例或两个参与者之间的关系扩展使得每个用例可以通过扩展用例向基用例中添加额外的行为来扩展基用例的功能。用例A扩展了用例B，那么A称为扩展用例或子用例，B表示为基用例。\n扩展用例A的事件流在一定的条件下按照相应的扩展点插入到及用例中，这就需要在及用例中定义一至多个已命名的扩展点。（这和继承关系不一样）。\n选用扩展关系可以把一些可选的操作独立封装在另外的用例中，避免基用例过于复杂。。\n泛化关系其实可以通俗理解为面向对象关系中的继承。将拥有一种类似的结构和行为的多个用例中的共性抽象为父用例，子用例继承父用例中的所有")])])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("扩展关系和包含关系的区别？")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("相同点：")])]),v._v(" "),r("ul",[r("li",[v._v("都是两个用例之间的关系。（只有泛化关系不仅可以表示两个用例，还可以是两个参与者之间）")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("不同点：")])]),v._v(" "),r("ul",[r("li",[r("strong",[v._v("条件性：")]),v._v(" "),r("ul",[r("li",[v._v("包含关系是无条件的")]),v._v(" "),r("li",[v._v("扩展关系是有条件的")])])]),v._v(" "),r("li",[r("strong",[v._v("插入原则：")]),v._v(" "),r("ul",[r("li",[v._v("包含关系中被包含用例的事件流一定插入到基用例中去。")]),v._v(" "),r("li",[v._v("扩展关系可以根据一定条件来决定是否将扩展用例的事件流插入到基用例事件流。")])])]),v._v(" "),r("li",[r("strong",[v._v("插入点：")]),v._v(" "),r("ul",[r("li",[v._v("包含关系中插入点只有一个。")]),v._v(" "),r("li",[v._v("扩展关系的插入点可以有多个。")])])])])])]),v._v(" "),r("p",[r("img",{attrs:{src:"/img/softwareRequire/7-1.png",alt:"img"}})]),v._v(" "),r("ul",[r("li",[r("strong",[v._v("系统边界：")]),v._v("\n界定系统的范围，在UML用例视图中使用system元素表示软件系统的范围。System可以包含一些用例，并界定系统的边界，边界之内的属于系统的功能和行为，边界之外的则不是系统所关心的内容。")])])])}),[],!1,null,null,null);_.default=i.exports}}]);