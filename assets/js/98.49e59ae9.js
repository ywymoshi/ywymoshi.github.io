(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{449:function(t,s,a){"use strict";a.r(s);var v=a(25),r=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("GOF定义")]),t._v("：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。\n"),a("ul",[a("li",[t._v("第一部分的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。")]),t._v(" "),a("li",[t._v("第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。")])])])]),t._v(" "),a("h2",{attrs:{id:"优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[t._v("#")]),t._v(" 优缺点")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("优点")]),t._v("：\n"),a("ul",[a("li",[t._v("❏ 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。")]),t._v(" "),a("li",[t._v("❏ 避免Context无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了Context中原本过多的条件分支。")]),t._v(" "),a("li",[t._v("❏ 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。")]),t._v(" "),a("li",[t._v("❏ Context中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。")])])]),t._v(" "),a("li",[a("strong",[t._v("缺点")]),t._v("：\n"),a("ul",[a("li",[t._v("状态模式的缺点是会在系统中定义许多状态类，编写20个状态类是一项枯燥乏味的工作，而且系统中会因此而增加不少对象。")]),t._v(" "),a("li",[t._v("另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。")])])])]),t._v(" "),a("h2",{attrs:{id:"最初的不总是最好的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最初的不总是最好的"}},[t._v("#")]),t._v(" 最初的不总是最好的")]),t._v(" "),a("p",[a("strong",[t._v("示例（切换灯泡的状态）")]),t._v(":")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("    \n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])])])}),[],!1,null,null,null);s.default=r.exports}}]);