(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{448:function(_,v,l){"use strict";l.r(v);var t=l(25),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[l("h2",{attrs:{id:"前言"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[_._v("#")]),_._v(" 前言")]),_._v(" "),l("h2",{attrs:{id:"类之间的6种关系"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#类之间的6种关系"}},[_._v("#")]),_._v(" 类之间的6种关系")]),_._v(" "),l("h2",{attrs:{id:"软件设计7宗罪"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#软件设计7宗罪"}},[_._v("#")]),_._v(" 软件设计7宗罪")]),_._v(" "),l("ol",[l("li",[l("strong",[_._v("僵化性")]),_._v(" "),l("ul",[l("li",[_._v("如果单一的改动会导致有依赖的模块的连锁改动，那么"),l("code",[_._v("设计就是僵化的")]),_._v("，需要连锁改动的模块越多，设计越僵化。")])])]),_._v(" "),l("li",[l("strong",[_._v("脆弱性")]),_._v(" "),l("ul",[l("li",[_._v("改动程序时，程序中许多与改动位置并没有其他关联地方也可能出现问题，即"),l("code",[_._v("设计易于遭受破坏")]),_._v("。")])])]),_._v(" "),l("li",[l("strong",[_._v("牢固性")]),_._v(" "),l("ul",[l("li",[_._v("指设计中包含了对其它系统有用的部分，但想要把这些部分分离出来所需要的努力和风险是巨大的，即"),l("code",[_._v("设计难以复用")])])])]),_._v(" "),l("li",[l("strong",[_._v("粘滞性")]),_._v(" "),l("ul",[l("li",[_._v("一个改动在保持原有设计意图和设计框架下进行，也可以破坏原始意图与框架进行")]),_._v(" "),l("li",[_._v("第一种办法对系统的未来有利，第二种办法是权宜之计，可以解决短期问题但会牺牲中长期利益")]),_._v(" "),l("li",[_._v("一个系统设计中，如果总是是的第二种方法比第一种方法来的容易，说明粘滞性过高")])])]),_._v(" "),l("li",[l("strong",[_._v("不必要的重复")]),_._v(" "),l("ul",[l("li",[_._v("滥用“复制”与“粘贴” 导致大量重复代码")])])]),_._v(" "),l("li",[l("strong",[_._v("不必要的复杂性")]),_._v(" "),l("ul",[l("li",[_._v("包含了过多没用用的成分，增加了软件的复杂性")])])]),_._v(" "),l("li",[l("strong",[_._v("晦涩性")]),_._v(" "),l("ul",[l("li",[_._v("其他人或软件设计人员自己难以理解所设计的软件，并且代码随时间而不断演化，变得越来越难以读懂。")])])])]),_._v(" "),l("h2",{attrs:{id:"一个好的设计"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#一个好的设计"}},[_._v("#")]),_._v(" 一个好的设计")]),_._v(" "),l("ol",[l("li",[l("strong",[_._v("可维护性")]),_._v(" "),l("ul",[l("li",[_._v("能够容易被理解、改正、适应、及拓展")])])]),_._v(" "),l("li",[l("strong",[_._v("可复用性")]),_._v(" "),l("ul",[l("li",[_._v("软件能够容易被重复使用的难以程度")])])])]),_._v(" "),l("h2",{attrs:{id:"_7个设计原则"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_7个设计原则"}},[_._v("#")]),_._v(" 7个设计原则")]),_._v(" "),l("ol",[l("li",[l("strong",[_._v("单一职责原则")]),_._v(" "),l("ul",[l("li",[_._v("一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中")])])]),_._v(" "),l("li",[l("strong",[_._v("开闭原则")]),_._v(" "),l("ul",[l("li",[_._v("软件实体应当对拓展开放，对修改关闭")])])]),_._v(" "),l("li",[l("strong",[_._v("里氏代换原则")]),_._v(" "),l("ul",[l("li",[_._v("所有引用基类的地方必须能透明地使用其子类的对象")])])]),_._v(" "),l("li",[l("strong",[_._v("依赖倒转原则")]),_._v(" "),l("ul",[l("li",[_._v("高层模块不应该依赖底层模块，他们都应依赖抽象模块，抽象不依赖于细节，细节应该依赖抽象。")])])]),_._v(" "),l("li",[l("strong",[_._v("接口隔离原则")]),_._v(" "),l("ul",[l("li",[_._v("客户端不应该依赖那些他不需要的接口")])])]),_._v(" "),l("li",[l("strong",[_._v("组合复用原则")]),_._v(" "),l("ul",[l("li",[_._v("优先使用对象组合，而不是继承来达到复用的目的")])])]),_._v(" "),l("li",[l("strong",[_._v("迪米特原则")]),_._v(" "),l("ul",[l("li",[_._v("如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的一个方法的话，可以通过第三者转发这个调用。")])])])]),_._v(" "),l("h2",{attrs:{id:"设计模式的分类"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的分类"}},[_._v("#")]),_._v(" 设计模式的分类")]),_._v(" "),l("ul",[l("li",[l("p",[_._v("创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。")])]),_._v(" "),l("li",[l("p",[_._v("结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。")])]),_._v(" "),l("li",[l("p",[_._v("行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);